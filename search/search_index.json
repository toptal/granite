{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Granite Framework","text":"<p>Granite is an architecture for business actions in Rails applications, combining user interaction (attributes and validations), context (preconditions), and permissions (authorization policies).</p>"},{"location":"#what-problems-does-granite-solve","title":"What problems does Granite solve","text":"<p>Granite employs patterns to increase productivity in developing growing applications. Instead of bloating the controller and model, business logic is placed in the <code>app/actions</code> directory.</p> <p>These atomic actions process data and execute arbitrary operations in response to user requests or programmatically, such as by a background worker or another action.</p>"},{"location":"#business-actions","title":"Business actions","text":"<p>The fundamental concept of Granite is the business action, which can be initiated with a simple <code>execute_perform!</code> method.</p>"},{"location":"#hello-world","title":"Hello World","text":"<p>In essence, a business action is an ActiveModel-like class (form object) designed to execute a sequence of commands. The basic business action takes the following form:</p> <pre><code>class Action &lt; Granite::Action\n  private def execute_perform!(*)\n    puts 'Hello World'\n  end\nend\n</code></pre> <p>There are 2 ways to execute a recently defined business action: <code>#perform!</code>, or <code>try_perform!</code>:</p> <ol> <li> <p><code>perform!</code> raises an exception when encountering errors.</p> </li> <li> <p><code>try_perform!</code> is comparable to <code>perform!</code> but doesn't execute the action if preconditions are not met.</p> </li> </ol> <p>Note: Business actions can currently also be executed with <code>#perform</code> method. It behaves the same as <code>try_perform!</code>, is deprecated and will be removed in next major version.</p>"},{"location":"#transactions","title":"Transactions","text":"<p>To ensure proper data management, each action execution is enclosed in a DB transaction using <code>ActiveRecord::Base.transaction(requires_new: true)</code>.</p> <pre><code>pry(main)&gt; Action.new.perform! # the same for `try_perform!`\n   (0.3ms)  BEGIN\nHello World\n   (0.1ms)  COMMIT\n=&gt; true\n</code></pre> <p>You can explicitly use <code>Granite::Action.transaction</code> and encapsulate any logic within a transaction:</p> <pre><code>Granite::Action.transaction do\n  some_other_logic\n  Action.new.perform!\n  AnotherAction.new.perform!\nend\n</code></pre>"},{"location":"#callbacks","title":"Callbacks","text":""},{"location":"#after_initialize","title":"<code>after_initialize</code>","text":"<p>This callback is triggered after an action has been initialized.</p> <pre><code>class Action &lt; Granite::Action\n  attribute :name, String\n\n  after_initialize do\n    self.name = 'Default'\n  end\n\n  # OR\n  # after_initialize :method_to_trigger\nend\n\nAction.new.name\n# =&gt; 'Default'\n</code></pre>"},{"location":"#after_commit","title":"<code>after_commit</code>","text":"<p>This callback is triggered after DB transaction has been committed.</p> <pre><code>class Action &lt; Granite::Action\n  ...\n\n  after_commit do\n    # any logic that relies on action results being in the database,\n    # such as scheduling jobs\n    puts 'after_commit triggered'\n  end\n\n  # OR\n  # after_commit :method_to_trigger\nend\n</code></pre> <pre><code>pry(main)&gt; Action.new.perform!\n   (0.3ms)  BEGIN\nHello World\n   (0.1ms)  COMMIT\nafter_commit triggered\n=&gt; true\n</code></pre>"},{"location":"#before-and-after-execute_perform","title":"before and after <code>execute_perform</code>","text":"<pre><code>class Action &lt; Granite::Action\n  ...\n\n  set_callback(:execute_perform, :before) do\n    puts 'before execute_perform'\n  end\n\n  set_callback(:execute_perform, :after, :after_execute_perform)\n\n  def after_execute_perform\n    puts 'after execute_perform'\n  end\nend\n</code></pre> <pre><code>pry(main)&gt; Action.new.perform!\n   (0.3ms)  BEGIN\nbefore execute_perform\nHello World\nafter execute_perform\n   (0.1ms)  COMMIT\n=&gt; true\n</code></pre>"},{"location":"#context-and-performer","title":"Context and performer","text":"<p>Each business action has a context, represented by a hash that can be assigned using the <code>.with</code> class method before the business action is initialized. The context is typically used to pass the performer of the action, which is so common that specific methods are defined to access and set the <code>performer</code>.</p> <pre><code>action = MyAction.with(performer: Admin.first).new(params)\naction.ctx #=&gt; #&lt;Granite::ContextProxy::Data performer: Admin.first&gt;\naction.performer #=&gt; Admin.first\n\naction = MyAction.as(Admin.first).new(params)\naction.ctx #=&gt; #&lt;Granite::ContextProxy::Data performer: Admin.first&gt;\naction.performer #=&gt; Admin.first\n</code></pre> <p>If your application requires additional attributes in the context, you can override the <code>BaseAction.with</code> and <code>BaseProjector.with</code> methods.</p> <pre><code>module GraniteContext\n  class Data &lt; Granite::ContextProxy::Data\n    def initialize(performer: nil, custom: false)\n      super(performer: performer)\n      @custom = custom\n    end\n  end\n\n  def with(data)\n    Granite::ContextProxy::Proxy.new(self, GraniteContext::Data.wrap(data))\n  end\nend\n\nBaseAction.extend GraniteContext\nBaseProjector.extend GraniteContext\n\nBaseAction.with(performer: performer, custom: true)\n</code></pre>"},{"location":"#attributes","title":"Attributes","text":"<p>The next step involves defining action attributes, which come in various types provided by the <code>granite-form</code> gem:</p> <pre><code>class Action &lt; Granite::Action\n  attribute :name, String\n  collection :ids, Integer\n\n  private def execute_perform!(*)\n    puts \"Hello #{name}! We have the following ids: #{ids}\"\n  end\nend\n</code></pre> <p>For comprehensive information on the available types and usage examples, please refer to the Granite Form documentation.</p> <p>The behavior of the attributes is similar to that of <code>Granite::Form</code> objects, with the exception of <code>represents</code>.</p>"},{"location":"#representing","title":"Representing","text":"<p>With Granite Form objects, when a model attribute is exposed via <code>represents</code> and the Active Record object changes, the exposed attribute is immediately updated.</p> <p>In contrast, Granite actions use <code>assign_data</code> to update the represented attribute.</p>"},{"location":"#assigning-the-data","title":"Assigning the data","text":"<p><code>assign_data</code> can be used to set blocks and methods that are invoked before the business action is validated. In practice, it can be implemented as follows:</p> <pre><code>class CreateBook &lt; Granite::Action\n  attribute :name, String\n  attribute :year, Integer\n  represents :author, of: :book\n\n  assign_data :set_name\n  assign_data do\n    book.year = year\n  end\n\n  private def set_name\n    book.name = name\n  end\nend\n</code></pre> <p>In this example, before the business action is validated, Granite will invoke the <code>assign_data</code> callbacks and set the book's author, name, and year (in that order).</p>"},{"location":"#associations","title":"Associations","text":"<p>Granite actions can also define several associations:</p> <pre><code>class CreateBook &lt; Granite::Action\n  attribute :name, String\n  references_one :author\n  embeds_many :reviews\nend\n</code></pre> <p>For comprehensive information on the available associations and usage examples, please refer to the Granite Form documentation.</p>"},{"location":"#nested-actions","title":"Nested actions","text":"<p>Some business actions call other actions as part of their own execution. In such cases, we need to define a memoizable method that returns an instance of the sub-action:</p> <pre><code>memoize def subaction\n  MySubactionClass.new\nend\n</code></pre> <p>Sub-actions validate their data and check preconditions when performed. However, it is not recommended to rely on this behavior. It is better to validate the sub-action when the main action is validated and check the preconditions of the sub-action when the preconditions of the main action are checked. For this, we use:</p> <pre><code>precondition embedded: :subaction\nvalidates :subaction, nested: true\n</code></pre>"},{"location":"#subject","title":"Subject","text":"<p>The definition of the subject does three things:</p> <ol> <li> <p>Defines a <code>references_one</code> association.</p> </li> <li> <p>Aliases its methods to common names (<code>subject</code> and <code>subject_id</code>)</p> </li> <li> <p>Modifies the action initializer to provide the ability to pass the subject as the first argument and restricts subject-less action initialization.</p> </li> </ol> <p>Let's take a look to an example below:</p> <pre><code>class Action &lt; Granite::Action\n  subject :user\n\n  private def execute_perform!(*); end\nend\n</code></pre> <pre><code>pry(main)&gt; Action.new\n=&gt; ArgumentError\n\npry(main)&gt; Action.new(User.first)\n=&gt; #&lt;Action user: #&lt;ReferencesOne #&lt;User id: 1...&gt;, user_id: 1&gt;\n\npry(main)&gt; Action.new(1)\n=&gt; #&lt;Action user: #&lt;ReferencesOne #&lt;User id: 1...&gt;, user_id: 1&gt;\n\npry(main)&gt; Action.new(user: User.first)\n=&gt; #&lt;Action user: #&lt;ReferencesOne #&lt;User id: 1...&gt;, user_id: 1&gt;\n\npry(main)&gt; Action.new(subject: User.first)\n=&gt; #&lt;Action user: #&lt;ReferencesOne #&lt;User id: 1...&gt;, user_id: 1&gt;\n\npry(main)&gt; Action.new(user_id: 1)\n=&gt; #&lt;Action user: #&lt;ReferencesOne #&lt;User id: 1...&gt;, user_id: 1&gt;\n\npry(main)&gt; Action.new(id: 1)\n=&gt; #&lt;Action user: #&lt;ReferencesOne #&lt;User id: 1...&gt;, user_id: 1&gt;\n</code></pre> <p>Notice that the method <code>#user</code> has been assigned to the alias <code>#subject</code>, and <code>#user_id</code> to <code>#id</code>. Furthermore, a <code>subject</code> call takes any combination of <code>references_one</code> possible options.</p>"},{"location":"#policies-preconditions-and-validations","title":"Policies, preconditions, and validations","text":"<p>When deciding how to structure policies, preconditions, and validations, there are some simple rules to follow:</p> <ol> <li> <p>If the condition depends on any user-provided attribute values except for the subject, it is a validation.</p> </li> <li> <p>If the condition depends on the subject or any value that depends on the subject, it is a precondition.</p> </li> <li> <p>Otherwise, if it is related to the performer, choose a policy.</p> </li> </ol>"},{"location":"#policies","title":"Policies","text":"<p>Policies are used to define restrictions on the performer of an action. The <code>allow_if</code> method can be used to specify a condition that must be met for the action to be allowed.</p> <p>For example, the following code specifies that an action can only be performed if the performer is present:</p> <pre><code>class Action &lt; Granite::Action\n  allow_if { performer.present? }\n  allow_self # equal to allow_if { performer == subject }\nend\n</code></pre> <p>There is also an <code>allow_self</code> method that is equivalent to <code>allow_if { performer == subject }</code>, which allows an action to be performed by the subject itself.</p> <p>Granite policies also support strategies:</p> <ol> <li> <p>By default, the <code>AnyStrategy</code> is used, which allows an action to be performed if any policy allows it.</p> </li> <li> <p>Other built-in strategies include <code>AlwaysAllowStrategy</code>, which allows all actions,</p> </li> <li> <p>And <code>RequiredPerformerStrategy</code>, which requires that a performer be present for all actions.</p> </li> </ol> <p>You can also write your own custom policy strategy.</p> <p>To use a custom policy strategy, you can set the <code>_policies_strategy</code> class variable to the desired strategy, like so:</p> <pre><code>class Action &lt; Granite::Action\n  self._policies_strategy = MyCustomStrategy\nend\n</code></pre>"},{"location":"#preconditions","title":"Preconditions","text":"<p>Preconditions are used for subject-related pre-validation and work similarly to validations with blocks. However, instead of using <code>errors.add</code>, the <code>decline_with</code> method is preferred.</p> <p>For example, you can use a precondition to check if the subject is active before performing an action:</p> <pre><code>precondition do\n  decline_with(:inactive) unless subject.active?\nend\n</code></pre> <p>If you have sub-actions that are performed within your main action, you can easily check their preconditions by embedding them:</p> <pre><code>precondition embedded: :my_custom_action\n</code></pre> <p>You can specify conditions for when the precondition block should be executed using the <code>:if</code> and <code>unless</code> statements:</p> <pre><code>precondition if: -&gt; { subject.active? } do\n  decline_with(:too_young) if subject.age &lt; 30\nend\n</code></pre>"},{"location":"#preconditions-as-objects","title":"Preconditions as objects","text":"<p>The <code>precondition</code> method can also accept a class that inherits from <code>Granite::Action::Precondition</code>. When defining a precondition this way, you can pass additional parameters to the precondition object, making it more reusable.</p> <p>The precondition method with a class argument supports the same options (<code>:if</code> and <code>:unless</code>) as defining a precondition as a block:</p> <pre><code>class AgeCheck &lt; Granite::Action::Precondition\n  description 'Must be old enough'\n\n  def call(**)\n    decline_with(:too_young) if subject.age &lt; 30\n  end\nend\n</code></pre> <p>This precondition can be used like this:</p> <pre><code>precondition AgeCheck, if: -&gt; { subject.active? }\n</code></pre>"},{"location":"#validations","title":"Validations","text":"<p>Granite supports using any of the validations provided by Active Model.</p>"},{"location":"#context-validations","title":"Context validations","text":"<p>Granite supports and encourages the use of context validations, which can be specified using the <code>on:</code> key with any validation to declare the context in which the validation should be executed. This means that these validations will only be triggered when the provided context is explicitly specified.</p> <p>To specify a context when using the built-in ActiveModel methods <code>valid?</code> and <code>invalid?</code>, simply provide the context as the first argument. When using <code>perform!</code>, or <code>try_perform!</code>, pass the name of the context as a keyword argument <code>context:</code>.</p> <p>Context validations should be used when different validation behavior is required in different scenarios (e.g., by a staff member and a non-staff user). For example, consider a simplified business action for updating a user's portfolio:</p> <pre><code>class BA::User::UpdatePortfolio &lt; Granite::Action\n  subject :user\n\n  represents :full_name, of: :subject\n\n  validates :full_name, presence: true, on: :user\n\n  private def execute_perform!(*)\n    # ...\n  end\nend\n</code></pre> <p>By default, running this business action using <code>perform!</code> won't require the <code>full_name</code> attribute to be present. However, if you want to enforce this validation, you can add a context argument to the perform call: <code>perform!(context: :user)</code>.</p>"},{"location":"#exception-handling","title":"Exception handling","text":"<p>Granite provides a built-in mechanism for exception handling, similar to the <code>rescue_from</code> method used in Action Controller. You can register handlers for any exception type using the <code>handle_exception</code> method.</p> <p><pre><code>class Action &lt; Granite::Action\n  handle_exception ThirdPartyLib::APIError do |error|\n    decline_with(:third_party_lib_failed)\n  end\n\n  private def execute_perform!(*)\n    ThirdPartyLib.api_call\n  end\nend\n</code></pre> In the example provided, <code>ThirdPartyLib::APIError</code> is caught, and the handler block adds an error to the action object with the message <code>:third_party_lib_failed</code>. It's important to add errors to the action object because, when a handled exception is raised, <code>Granite::Action::ValidationError</code> is raised with the same backtrace as the original error.</p>"},{"location":"#dependency-injection","title":"Dependency Injection","text":"<p>Dependency Injection is a programming technique that allows you to remove hard-coded dependencies from your code and instead provide them externally. Granite's default attribute assignment mechanism may not always be suitable for this, but you can use custom initializers to achieve DI:</p> <pre><code>class Action &lt; Granite::Action\n  attribute :name, String\n\n  private attr_reader :my_dep\n\n  def initialize(*args, my_dep: Foo.new, **kwargs, &amp;block)\n    @my_dep = my_dep\n    super(*args, **kwargs, &amp;block)\n  end\nend\n\nAction.new(name: \"Jane\")                  # uses default value for `my_dep'\nAction.new(name: \"Jane\", my_dep: Bar.new) # uses custom value for `my_dep'\n</code></pre> <p>In the example code, <code>my_dep</code> is a dependency that is provided to the action through the initialize method, rather than being hardcoded in the attribute definition. The <code>my_dep</code> dependency is set to a default value of <code>Foo.new</code>, but it can be overridden by passing a <code>my_dep</code> keyword argument to the constructor.</p> <p>By using this technique, you can easily provide dependencies to your Granite actions from an external source, making your code more modular and testable.</p>"},{"location":"#i18n","title":"I18n","text":"<p>When using the I18n feature, if an identifier is prefixed with a dot (<code>t('.foobar')</code>), translations will be looked up in the following order:</p> <pre><code>granite_action.#{granite_action_name}.foobar\ngranite_action.granite/action.foobar\nfoobar\n</code></pre> <p>It's important to note that the lookup rules are different when performing an I18n lookup within a projector context. See the section on I18n lookup inside a projector context for more information.</p>"},{"location":"#generators","title":"Generators","text":"<p>You can use the granite generator to create a starting point for your action. To do so, pass the name and path of your action as the first argument using the following syntax:</p> <pre><code>rails g granite SUBJECT/ACTION [PROJECTOR]\n</code></pre> <p>If you want to generate a collection action where the subject is not known at initialization, use the <code>-C</code> or <code>--collection</code> option. You can also specify the projector name as a second argument when using the generator.</p> <p>Here are some examples of using the rails g granite command:</p> <ol> <li> <p><code>rails g granite user/create</code></p> <p>This command generates a new action called \"create\" for the \"user\" <code>subject</code>. It creates three files: <code>apq/actions/ba/user/create.rb</code>, <code>apq/actions/ba/user/business_action.rb</code>, and <code>spec/apq/actions/ba/user/create_spec.rb</code>.</p> </li> <li> <p><code>rails g granite user/create -C</code></p> <p>Adding the <code>-C</code> option generates a collection action where the subject is not known at initialization. This command generates two files: <code>apq/actions/ba/user/create.rb</code> and <code>spec/apq/actions/ba/user/create_spec.rb</code>.</p> </li> <li> <p><code>rails g granite user/create simple</code></p> <p>Adding a second argument, such as \"simple\" specifies the name of the projector to use. This command generates a new directory called simple within the <code>apq/actions/ba/user/create directory</code>, as well as the same files as the first example: <code>apq/actions/ba/user/create.rb</code>, <code>apq/actions/ba/user/business_action.rb</code>, and <code>spec/apq/actions/ba/user/create_spec.rb</code>.</p> </li> </ol>"},{"location":"#conclusion","title":"Conclusion","text":"<p>We hope this introduction to Granite has piqued your interest and given you a glimpse into the power and simplicity of this framework. Give it a try and see how Granite can streamline your business logic and take your Ruby on Rails applications to the next level.</p>"},{"location":"projectors/","title":"Projectors","text":"<p>If you need a simpler way to handle complex logic in your existing controller, you can use the Granite action by calling it in the controller action:</p> <pre><code>class MoviesController &lt; ApplicationController\n  # ...\n  # Regular controller definition\n  # ...\n  def create\n    BA::Movies::Create.with(performer: current_user).new(some_params).perform!\n  end\n  # ...\nend\n</code></pre> <p>However, this code can quickly become repetitive, so it's recommended to use projectors instead.</p> <p>Projectors are mainly used to avoid duplicating code in controller actions and decorator methods. They enable business actions to be rendered into a user interface more easily.</p>"},{"location":"projectors/#basics","title":"Basics","text":"<p>A projector file has two parts: </p> <ol> <li> <p>Decorator part is the projector class itself.</p> </li> <li> <p>Controller part is a nested class defined implicitly and accessible via <code>TestProjector.controller_class</code>.</p> </li> </ol> <p>For example:</p> <pre><code>class TestProjector &lt; Granite::Projector\nend\n</code></pre> <p>To mount projectors into actions and routes, you can use the projector method. It's possible to mount multiple projectors onto one action (e.g., if we need to execute a business action through a standard confirmation dialog or inline editing) or to have one projector mounted by several actions:</p> <pre><code>class Action &lt; Granite::Action\n  projector :test\n\n  # Alternatively, you can specify a custom name:\n  # projector :main, class_name: 'TestProjector'\nend\n</code></pre> <p>When a projector is mounted onto an action, an inherited projector and a controller class are created:</p> <pre><code>pry(main)&gt; Action.test\n=&gt; Action::TestProjector\n\npry(main)&gt; Action.test.controller_class\n=&gt; Action::TestController\n\npry(main)&gt; Action.test.action_class\n=&gt; Action(no attributes)\n\npry(main)&gt; Action.test.controller_class.action_class\n=&gt; Action(no attributes)\n</code></pre> <p>To mount projectors onto routes, you need to specify a path to the projector as a string. If a business action has multiple projectors, each of them must be mounted separately in the routes. If an action doesn't have a subject, it should be mounted explicitly inside the <code>collection</code> block:</p> <p>When you call <code>granite</code> in the routes, every controller of every mounted projector for the specified action is taken, and its controller actions are mounted onto the routes. You can also mount specific projectors.</p> <p>Projectors can only be mounted inside a resource, and they are mounted on <code>:member</code> if they have a <code>subject</code> and on <code>:collection</code> otherwise:</p> <pre><code>Application.routes.draw do\n  resources :users, only: [:index] do\n    collection do\n      granite 'create#my_projector'\n    end\n\n    granite 'remove#my_projector'\n  end\nend\n</code></pre> <p>When you mount a projector onto a route, the route will be defined by the resources block and the string provided. The Granite action and projector will be inferred by the parameter, which is split by the <code>#</code> character.</p> <p>For instance, in the previous code block, the route <code>/users/create/:projector_action</code> is created, where the action is <code>Create</code> and the projector is <code>MyProjector</code>. </p> <p>Next code block shows how the <code>:projector_action</code> refers to the projector controller action (<code>baz</code> and <code>bar</code>):</p> <pre><code>class FooProjector &lt; Granite::Projector\n  get :baz, as: '' do\n    # ...\n  end\n\n  get :bar do\n    render json: { cats: 'nice' }\n  end\nend\n\nclass Action &lt; Granite::Action\n  projector :foo\nend\n\n# config/routes.rb\n# ...\nresources :bunnies do\n  granite 'action#foo'\nend\n</code></pre> <p>In this context, the route <code>/bunnies/action/bar</code> corresponds to the <code>bar</code> action in the <code>FooProjector</code>, and <code>/bunnies/action</code> leads to the <code>baz</code> action in the same <code>FooProjector</code>.</p> <p>Usually, projectors are mounted under <code>/:action/:projector_action</code>, where <code>:action</code> is the name of the BA, and <code>:projector_action</code> is mapped to the projector controller action.</p> <p>Please note that if you have multiple projectors for the same action, they might use the same routes. To avoid conflicts between projectors, it's recommended to mount the second projector with <code>projector_prefix: true</code>. This will mount the projector under <code>/:projector_:action/:projector_action</code> instead of <code>/:action/:projector_action</code>. The same goes for the path helper method, which will be <code>projector_action_subject_path</code> instead of <code>action_subject_path</code>.</p> <p>You can also customize the mount path using <code>path: '/my_custom_path', as: :my_custom_action</code>.</p> <p>It's also possible to restrict the HTTP verbs for actions using <code>via: :post</code> (or <code>:get</code>, or any valid HTTP-action).</p> <p>Lastly, you can access the projector instance from the action instance using the projector name:</p> <pre><code>pry(main)&gt; Action.new.test\n=&gt; #&lt;Action::TestProjector:0x007f98bde9ac98 @action=#&lt;Action (no attributes)&gt;&gt;\n\npry(main)&gt; Action.new.test.action\n=&gt; #&lt;Action (no attributes)&gt;\n</code></pre>"},{"location":"projectors/#i18n-projectors-lookup","title":"I18n projectors lookup","text":"<p>In Granite actions, there are special I18n rules that apply to projectors. When the I18n identifier is prefixed with a dot (<code>t('.foobar')</code>), translations are looked up in the following order:</p> <pre><code>granite_action.ba/#{granite_action_name}.#{granite_projector_name}.#{view_name}.foobar\ngranite_action.ba/#{granite_action_name}.#{granite_projector_name}.foobar\ngranite_action.base_action.#{granite_projector_name}.#{view_name}.foobar\ngranite_action.base_action.#{granite_projector_name}.foobar\ngranite_action.granite/action.#{granite_projector_name}.#{view_name}.foobar\ngranite_action.granite/action.#{granite_projector_name}.foobar\n#{granite_projector_name}.#{view_name}.foobar\n#{granite_projector_name}.foobar\n</code></pre>"},{"location":"projectors/#decorator-part","title":"Decorator part","text":"<p>Since projectors behave like decorators, you can define helpers at the projector instance level. For example:</p> <pre><code>class TestProjector &lt; Granite::Projector\n  def link\n    h.link_to action.subject.full_name, action.subject\n  end\nend\n\nclass Action &lt; Granite::Action\n  projector :test\n  subject :user\nend\n</code></pre> <p>In your application, you can call this helper method like this:</p> <pre><code>Action.new(User.first).test.link\n# =&gt; \"&lt;a href=\\\"/user/112014\\\"&gt;Sebasti\u00e1n L\u00f3pez Alfonso&lt;/a&gt;\"\n</code></pre> <p>This will generate a link to the <code>User</code> object's page with the user's full name as the link text. The <code>link</code> method is defined in the <code>TestProjector</code> and is called on the test projector instance that is associated with the <code>Action</code> object. The <code>h</code> helper method is provided by the projector instance and allows you to use Rails view helpers in your projector methods.</p>"},{"location":"projectors/#controller-part","title":"Controller part","text":"<p>The primary role of a controller is to serve actions, but in order to automatically detect controller actions and dispatch requests to them, we need a small DSL. Here's an example:</p> <pre><code>class TestProjector &lt; Granite::Projector\n  get :help do\n    # render a view that shows help\n  end\n\n  get :form, as: '' do\n    # render a form. This is a default `get` action for this controller\n  end\n\n  post :perform, as: '' do\n    # process the form. This is a default `post` action for this controller\n  end\nend\n</code></pre> <p>The first part of this code is the verb definition, which can be any REST verb. The second part is the mount point name to create a beautiful URL. You can set it using the <code>:as</code> option, and it's recommended to set it to an empty string so that the actual controller action isn't part of the URL.</p> <p>For example, if you mounted the <code>BA::Company::Create</code> business action that had a projector with a <code>perform</code> controller action, the default path to the action would be <code>create/perform</code>. By adding <code>as: ''</code> to the <code>perform</code> action definition, you can change the path to <code>create</code>.</p> <p>Note that the provided code defines methods called <code>help</code>, <code>form</code>, and <code>perform</code> in the <code>controller_class</code>. Also, keep in mind that calling <code>render</code> inside those blocks doesn't implicitly render the view within the application layout. To do so, you need to pass <code>layout: 'application'</code> to the <code>render</code> call.</p>"},{"location":"projectors/#customizations","title":"Customizations","text":"<p>The <code>Granite::Controller</code> is a subclass of <code>ActionController::Base</code> by default. However, it can be customized by changing the base_controller attribute in the Granite module's initializer. For example, to change the base controller to <code>ApplicationController</code>, you can do the following:</p> <pre><code>Granite.tap do |m|\n  m.base_controller = 'ApplicationController'\nend\n</code></pre> <p>In order to set the performer for Granite actions, you can implement the <code>projector_performer</code> method. For example, if you want to use the <code>current_user</code> method as the performer for all Granite actions, you can do the following:</p> <pre><code>def projector_performer\n  current_user\nend\n</code></pre> <p>It's worth noting that <code>Granite::Controller</code> can be further customized after running the <code>rails generate granite:install_controller</code> command. The original controller will be installed in <code>app/controllers/granite/controller.rb</code>, which can be modified to fit your specific needs.</p>"},{"location":"projectors/#handling-policy-exception","title":"Handling policy exception","text":"<p>When an action's policies are not satisfied, Granite raises a <code>Granite::Action::NotAllowedError</code> exception. To handle this exception in the <code>base_controller_class</code>, you can use the <code>rescue_from</code> method like this:</p> <pre><code>class ApplicationController &lt; ActionController::Base\n  rescue_from Granite::Action::NotAllowedError do |exception|\n    # Handle the exception\n  end\nend\n</code></pre> <p>Inside the block, you can define how to handle the exception, for example by rendering an error page or redirecting the user to a different page.</p>"},{"location":"projectors/#extending-projectors","title":"Extending projectors","text":"<p>To provide more flexibility in customizing projectors, Granite allows passing a block to the projector declaration when mounting to business actions. This block can be used to configure the projector or even extend its controller class.</p> <p>Here's an example:</p> <pre><code>class Action &lt; Granite::Action\n  projector :test do\n    controller_class.before_action { ... }\n\n    def link_class\n      'super-link'\n    end\n  end\nend\n</code></pre> <p>In this example, the <code>before_action</code> hook is added to the controller class and a new method <code>link_class</code> is defined.  While using a block to modify projectors is useful for small changes, it's often preferable to derive a new projector from a standard one for more significant modifications.</p>"},{"location":"projectors/#views","title":"Views","text":"<p>Views for projectors are used in the same way as views for usual controllers but are stored and inherited differently. Basic views for projectors are stored in <code>apq/projectors/#{projector_name}</code> directory.</p> <p>If you need to redefine a specific template for a particular action, you can do so by placing the template in <code>apq/actions/ba/#{action_name}/#{projector_name}</code> for <code>BA::ActionName.projector_name</code> projector.</p>"},{"location":"testing/","title":"Testing","text":"<p>Granite provides several RSpec helpers for testing your application. To use them, add <code>require 'granite/rspec'</code> to your <code>rails_helper.rb</code> file.</p> <p>All specs that live in <code>spec/apq/actions/</code> will get tagged with <code>:granite_action</code> type and will have access to Granite action specific helpers.</p> <p>All specs that live in <code>spec/apq/projectors/</code> will get tagged with <code>:granite_projector</code> type and will have access to Granite projector specific helpers.</p>"},{"location":"testing/#subject","title":"Subject","text":"<p>The subject is an instance of the action being tested. You can create it using the <code>as</code> method to specify the performer, and passing any necessary attributes as arguments. Here's an example:</p> <pre><code>subject(:action) { described_class.as(performer).new(user, attributes) }\nlet(:user) { User.new }\nlet(:attributes) { {} }\n</code></pre>"},{"location":"testing/#projectors","title":"Projectors","text":"<p>You can test your projectors using the <code>have_projector</code> matcher. Here's an example:</p> <pre><code>it { is_expected.to have_projector(:simple) }\n</code></pre> <p>You can also test overridden projector methods like this:</p> <pre><code>describe 'projectors', type: :granite_projector do\n  subject { action.modal }\n  projector { described_class.modal }\n\n  it { expect(projector.perform_success_response).to eq(my_success: 'yes') }\nend\n</code></pre> <p>If you need to test controller methods, you can do so like this:</p> <pre><code>describe 'projectors', type: :granite_projector do\n  projector { described_class.modal }\n  before { get :confirm, params: attributes }\n  it { expect(response).to be_successful }\nend\n</code></pre> <p>To test projectors, you can define a abstract action class and use it to test the projector like this:</p> <pre><code>describe SimpleProjector do\n  let(:dummy_action_class) do\n    Class.new BaseAction do\n      projector :simple\n    end\n  end\n\n  prepend_before do\n    stub_const('DummyAction', dummy_action_class)\n  end\n\n  projector { DummyAction.simple }\n\n  it { expect(projector.some_method).to eq('some_result') }\nend\n</code></pre>"},{"location":"testing/#policies","title":"Policies","text":"<p>You can test action policies using the <code>be_allowed</code> matcher like this:</p> <pre><code>subject { described_class.as(User.new).new }\nit { is_expected.to be_allowed }\n</code></pre>"},{"location":"testing/#preconditions","title":"Preconditions","text":"<p>You can test action preconditions using the <code>satisfy_preconditions</code> matcher. Here's an example:</p> <pre><code>context 'correct initial state' do\n  it { is_expected.to satisfy_preconditions }\nend\n\ncontext 'incorrect initial state' do\n  let(:company) { build_stubbed(:company, :active) }\n  it { is_expected.not_to satisfy_preconditions.with_message(\"Some validation message\") }\n  it { is_expected.not_to satisfy_preconditions.with_messages([\"First validation message\", \"Second validation message\"]) }\nend\n</code></pre>"},{"location":"testing/#validations","title":"Validations","text":"<p>Validations tests are no different to Active Record models tests.</p>"},{"location":"testing/#performing","title":"Performing","text":"<p>You can use the <code>perform!</code> method to run the action and test its side-effects like this:</p> <pre><code>specify { expect { perform! }.to change(User, :count).by(1) }\n</code></pre>"},{"location":"testing/#testing-action-is-performed-from-another-action","title":"Testing action is performed from another action","text":"<p>You can test that an action is performed from another action using the <code>perform_action</code> matcher. Here's an example:</p> <pre><code>it { expect { perform! }.to perform_action(MyAction) }\nit { expect { perform! }.to perform_action(MyAction).as(performer).with(user: user).using(:try_perform!) }\n</code></pre>"},{"location":"tutorial/","title":"Application example","text":"<p>The business we will be discussing is simple. We plan to establish a book library where registered users can create new books and rent them.</p>"},{"location":"tutorial/#book-library-requirements","title":"Book library requirements","text":"<p>We need a basic book tracking system in which every book is identified by a title. The following rules will apply:</p> <ul> <li>The book list will be publicly accessible to everyone.</li> <li>Only users who are logged in will be allowed to modify the book list.</li> <li>Logged-in users will have the ability to edit or delete a book.</li> </ul>"},{"location":"tutorial/#the-rental-system","title":"The rental system","text":"<p>Logged-in users will have the ability to manage books, taking into account the following:</p> <ul> <li>Users should be able to rent any available book.</li> <li>Only logged-in users will be able to rent books.</li> <li>A book will be marked as unavailable while it is rented out to someone.</li> <li>After a book is returned, it will be marked as available once again.</li> </ul>"},{"location":"tutorial/#the-books-wishlist","title":"The books wishlist","text":"<p>Logged-in users will have the ability to manage their wishlist, taking into account the following:</p> <ul> <li>Users should be able to add books to their wishlist if the book is currently unavailable and they have not yet read it.</li> <li>If a user has already read a book, adding it to their wishlist would not be practical.</li> <li>Once a book on a user's wishlist becomes available, the system should notify them.</li> <li>When the book is rented by someone that has the book on the wishlist, it should be removed after return.</li> </ul> <p>The application domain is straightforward, and we will be building this small logic case step by step to demonstrate how Granite can simplify and streamline certain aspects of your application.</p>"},{"location":"tutorial/#new-project-setup","title":"New project setup","text":"<p>We are working here with Rails 5.1, however, Granite currently supports Rails versions up to <code>7.x.x</code>. You can find an example of this application following the link: https://github.com/toptal/example_granite_application</p>"},{"location":"tutorial/#generating-a-new-project","title":"Generating a new project","text":"<p>This tutorial is using Rails version <code>5.1.4</code>, and the first step is to install it:</p> <pre><code>gem install rails -v=5.1.4\n</code></pre> <p>Now, with the proper Rails version, let's start a new project:</p> <pre><code>rails new library\ncd library\n</code></pre> <p>Let's start setting up the database for development: <pre><code>rails db:setup\n</code></pre></p>"},{"location":"tutorial/#setup-devise","title":"Setup Devise","text":"<p>Let's add devise to control users access and have a simple control over logged users. Adding it to <code>Gemfile</code>.</p> <pre><code>gem 'devise'\n</code></pre> <p>Run <code>bundle install</code> and then generate the default devise resources.</p> <pre><code>rails generate devise:install\n</code></pre> <p>And then, let's create a simple devise model to interact with:</p> <pre><code>rails generate devise user\n</code></pre> <p>And migrate again:</p> <pre><code>rails db:migrate\n</code></pre> <p>Info</p> <p>If you get in any trouble in this section, please check the updated documentation on the official website.</p>"},{"location":"tutorial/#setup-granite","title":"Setup Granite","text":"<p>Add <code>granite</code> to your <code>Gemfile</code>:</p> <pre><code>gem 'granite'\n</code></pre> <p>And <code>bundle install</code> again.</p> <p>Add <code>require 'granite/rspec'</code> to your <code>rails_helper.rb</code>. Check more details on the testing section.</p> <p>Warning</p> <p>If you get in any trouble in this section, please report an issue.</p>"},{"location":"tutorial/#books-domain","title":"Books domain","text":""},{"location":"tutorial/#bookcreate-action","title":"Book::Create action","text":"<p>It's time to create our first model and has some domain on it.</p> <p>Let's use a scaffold to have a starting point with the <code>Book</code> model:</p> <pre><code>rails g scaffold book title:string\n</code></pre> <p>Now, we can start working on the first business action.</p> <p>Let's generate the boilerplate business action class with Rails <code>granite</code> generator:</p> <pre><code>rails g granite book/create\n</code></pre> <p>The following class was generated:</p> <pre><code># apq/actions/ba/book/create.rb\nclass BA::Book::Create &lt; BA::Book::BusinessAction\n  allow_if { false }\n\n  precondition do\n  end\n\n  private\n\n  def execute_perform!(*)\n    subject.save!\n  end\nend\n</code></pre> <p>Additionally, a \"base\", shared class is generated, that defines the subject type for all the inherited classes in the namespace Book.</p> <pre><code>class BA::Book::BusinessAction &lt; BaseAction\n  subject :book\nend\n</code></pre>"},{"location":"tutorial/#policies","title":"Policies","text":"<p>The generated code says <code>allow_if { false }</code> and we need to restrict it to logged in users. Let's replace this line to restrict the action only for logged in users:</p> <pre><code># apq/actions/ba/book/create.rb\nclass BA::Book::Create &lt; BA::Book::BusinessAction\n  allow_if { performer.is_a?(User) }\n  # ...\nend\n</code></pre> <p>And let's start testing it:</p> <pre><code>require 'rails_helper'\nRSpec.describe BA::Book::Create do\n  subject(:action) { described_class.as(performer).new }\n  let(:performer) { User.new }\n\n  describe 'policies' do\n    it { is_expected.to be_allowed }\n\n    context 'when the user is not authorized' do\n      let(:performer) { double }\n      it { is_expected.not_to be_allowed }\n    end\n  end\nend\n</code></pre>"},{"location":"tutorial/#attributes","title":"Attributes","text":"<p>We also need to be specific about what attributes this action can touch and then we need to define attributes for it:</p> <pre><code># apq/actions/ba/book/create.rb\nclass BA::Book::Create &lt; BA::Book::BusinessAction\n  # ...\n  represents :title, of: :subject\n  # ...\nend\n</code></pre> <p>We can define some validations to not allow saving without specifying a title:</p> <pre><code># apq/actions/ba/book/create.rb\nclass BA::Book::Create &lt; BA::Book::BusinessAction\n  # ...\n  validates :title, presence: true\n  # ...\nend\n</code></pre> <p>And now we can properly test it:</p> <pre><code>require 'rails_helper'\n\nRSpec.describe BA::Book::Create do\n  subject(:action) { described_class.as(performer).new(attributes) }\n\n  let(:performer) { User.new }\n  let(:attributes) { { 'title' =&gt; 'Ruby Pickaxe'} }\n\n  describe 'policies' do\n    it { is_expected.to be_allowed }\n\n    context 'when the user is not authorized' do\n      let(:performer) { double }\n      it { is_expected.not_to be_allowed }\n    end\n  end\n\n  describe 'validations' do\n    it { is_expected.to be_valid }\n\n    context 'when preconditions fail' do\n      let(:attributes) { { } }\n      it { is_expected.not_to be_valid }\n    end\n  end\nend\n</code></pre>"},{"location":"tutorial/#perform","title":"Perform","text":"<p>For now, the perform is a simple call to <code>book.save!</code> because Granite already assign the attributes.</p> <p>Then we need to test if it's generating the right record:</p> <pre><code>require 'rails_helper'\n\nRSpec.describe BA::Book::Create do\n  subject(:action) { described_class.as(performer).new(attributes) }\n\n  let(:performer) { User.new }\n  let(:attributes) { { 'title' =&gt; 'Ruby Pickaxe'} }\n\n  describe 'policies' do\n    it { is_expected.to be_allowed }\n\n    context 'when the user is not authorized' do\n      let(:performer) { double }\n      it { is_expected.not_to be_allowed }\n    end\n  end\n\n  describe 'validations' do\n    it { is_expected.to be_valid }\n\n    context 'when preconditions fail' do\n      let(:attributes) { { } }\n      it { is_expected.not_to be_valid }\n    end\n  end\n\n+   describe '#perform!' do\n+     specify do\n+       expect { action.perform! }.to change { Book.count }.by(1)\n+       expect(action.subject.attributes.except('id', 'created_at', 'updated_at')).to eq(attributes)\n+     end\n+   end\nend\n</code></pre> <p>The last step is to replace the current book creation in the controller to call the business action instead.</p> <p>First thing is rescue from <code>Granite::NotAllowed</code> when some action is not allowed to be executed.</p> <pre><code>class BooksController &lt; ApplicationController\n  rescue_from Granite::Action::NotAllowedError do |exception|\n    redirect_to books_path, alert: \"You're not allowed to execute this action.\"\n  end\n  # ...\nend\n</code></pre> <p>It will generically manage exceptions in case some unauthorized user tries to force acting without having access.</p> <p>The next step is to wrap the method <code>#create</code> with the proper business action call.</p> <pre><code>class BooksController &lt; ApplicationController\n\n  # ...\n\n  # POST /books\n  def create\n    book_action = BA::Book::Create.as(current_user).new(book_params)\n      if book_action.perform\n        redirect_to book_action.subject, notice: 'Book was successfully created.'\n      else\n        @book = book_action.subject\n        render :new\n      end\n    end\n  end\n\n  # ...\nend\n</code></pre>"},{"location":"tutorial/#bookrent-action","title":"Book::Rent action","text":"<p>To start renting the book, we need a few steps:</p> <ol> <li>Generate migration to create the rental table referencing the book and the user</li> <li>Add an <code>available</code> boolean column in the books table</li> <li>Create a business action <code>Book::Rent</code> and test the conditions above</li> </ol> <p>Let's create <code>Rental</code> model first:</p> <pre><code>rails g model rental book:references user:references returned_at:timestamp\n</code></pre> <p>and add an <code>available</code> column in the books table:</p> <pre><code>rails g migration add_availability_to_books available:boolean\n</code></pre> <p>Now it's time to generate the next Granite action:</p> <pre><code>rails g granite book/rent\n</code></pre>"},{"location":"tutorial/#preconditions","title":"Preconditions","text":"<p>Let's write specs for the preconditions first:</p> <pre><code>RSpec.describe BA::Book::Rent do\n  subject(:action) { described_class.as(performer).new(book) }\n\n  let(:performer) { User.new }\n\n  let(:book) { Book.new(title: 'First book', available: available) }\n\n  describe 'preconditions' do\n    context 'with an available book' do\n      let(:available) { true }\n      it { is_expected.to satisfy_preconditions }\n    end\n\n    context 'with an unavailable book' do\n      let(:available) { false }\n      it { is_expected.to be_invalid }\n      it { is_expected.not_to satisfy_preconditions }\n    end\n  end\nend\n</code></pre> <p>Preconditions are related to the book in the context. And the action will decline the context not to be executed if it does not satisfy the preconditions.</p> <p>Let's implement the <code>precondition</code> and <code>perform!</code> code:</p> <pre><code>class BA::Book::Rent &lt; BA::Book::BusinessAction\n+ precondition { book.available? }\n\n  private\n\n  def execute_perform!(*)\n    Rental.create!(book: subject, user: performer)\n    subject.available = false\n    subject.save!\n  end\nend\n</code></pre> <p>Now, let's cover the perform with another spec:</p> <pre><code>RSpec.describe BA::Book::Rent do\n  subject(:action) { described_class.as(performer).new(book) }\n\n  let(:performer) { User.new }\n\n  let(:book) { Book.new(title: 'First book', available: available) }\n\n+ describe 'preconditions' do\n+   context 'with an available book' do\n+     let(:available) { true }\n+     it { is_expected.to satisfy_preconditions }\n+   end\n+\n+   context 'with an unavailable book' do\n+     let(:available) { false }\n+     it { is_expected.to be_invalid }\n+     it { is_expected.not_to satisfy_preconditions }\n+   end\n+ end\n\n  describe '#perform!' do\n    specify do\n      expect { action.perform! }\n        .to change(book, :available).from(true).to(false)\n        .and change(Rental, :count).by(1)\n    end\n  end\nend\n</code></pre>"},{"location":"tutorial/#bookreturn-action","title":"Book::Return action","text":"<p>First, think about the policies: to return the book, it needs to be rented by the person that is logged in.</p> <p>Then we need to have a precondition to verify if the current book is being rented by this person:</p> <pre><code>class BA::Book::Return &lt; BA::Book::BusinessAction\n  precondition do\n    rental_conditions = { book: subject, user: performer, returned_at: nil }\n    Rental.where(rental_conditions).exists?\n  end\nend\n</code></pre> <p>The logic of the return, we just need to pick the current rental and assign the <code>returned_at</code> date. Also, make the book available again.</p> <p>Let's start by testing the preconditions and guarantee that only the user that rent the book can return it.</p> <pre><code>RSpec.describe BA::Book::Return do\n  subject(:action) { described_class.as(performer).new(book) }\n\n  let(:book) { Book.create! title: 'Learn to fly', available: true }\n  let(:performer) { User.create! }\n\n  describe 'preconditions' do\n    context 'when the user rented the book' do\n      before { BA::Book::Rent.as(performer).new(book).perform! }\n      it { is_expected.to satisfy_preconditions }\n    end\n\n    context 'when preconditions fail' do\n      it { is_expected.not_to satisfy_preconditions }\n    end\n  end\nend\n</code></pre> <p>And implementing the preconditions:</p> <pre><code>class BA::Book::Return &lt; BA::Book::BusinessAction\n\n  subject :book\n  allow_if { performer.is_a?(User) }\n\n  precondition do\n    decline_with(:not_renting) unless performer.renting?(book)\n  end\nend\n</code></pre> <p>And the <code>User</code> now have a few scopes and the <code>#renting?</code> method:</p> <pre><code>class User &lt; ApplicationRecord\n  devise :database_authenticatable, :registerable\n  has_many :rentals\n  has_many :books, through: :rentals\n\n  def renting?(book)\n    rentals.current.where(book: book).exists?\n  end\nend\n</code></pre> <p>Now implementing the spec that covers the logic of return, is expected to make the book available and mark the rental with the given date.</p> <pre><code>RSpec.describe BA::Book::Return do\n  subject(:action) { described_class.as(performer).new(book) }\n\n  let(:book) { Book.create! title: 'Learn to fly', available: true }\n  let(:performer) { User.create! }\n\n  describe 'preconditions' do\n    context 'when the user rented the book' do\n      before { BA::Book::Rent.as(performer).new(book).perform! }\n      it { is_expected.to satisfy_preconditions }\n    end\n\n    context 'when preconditions fail' do\n      it { is_expected.not_to satisfy_preconditions }\n    end\n  end\n\n+   describe '#perform!' do\n+     let!(:rental) { Rental.create! book: book, user: performer }\n+\n+     specify do\n+       expect { action.perform! }\n+         .to change { book.reload.available }.from(false).to(true)\n+         .and change { rental.reload.returned_at }.from(nil)\n+     end\n+   end\nend\n</code></pre>"},{"location":"tutorial/#i18n","title":"I18n","text":"<p>The last step to make it user-friendly and return a personalized message when the business action calls <code>decline_with(:unavailable)</code>.</p> <p>It's time to create the internationalization file for it.</p> <p>File: <code>config/locales/granite.en.yml</code> <pre><code>en:\n  granite_action:\n    errors:\n      models:\n        ba/book/rent:\n          attributes:\n            base:\n              unavailable: 'The book is unavailable.'\n</code></pre></p>"},{"location":"tutorial/#application-layer","title":"Application layer","text":"<p>Great! Now it's time to change our views to allow people to interact with the actions we created.</p> <p>First, we need to add controller methods to call the <code>Rent</code> and <code>Return</code> business actions and create routes for it.</p> <pre><code>class BooksController &lt; ApplicationController\n\n  # a few other scaffold methods here\n\n  # POST /books/1/rent\n  def rent\n    @book = Book.find(params[:book_id])\n    book_action = BA::Book::Rent.as(current_user).new(@book)\n    if book_action.perform\n      redirect_to books_url, notice: 'Enjoy the book!'\n    else\n      redirect_to books_url, alert:  book_action.errors.full_messages\n    end\n  end\n\n  # POST /books/1/return_book\n  def return_book\n    @book = Book.find(params[:book_id])\n    book_action = BA::Book::Return.as(current_user).new(@book)\n      if book_action.perform\n        redirect_to books_url, notice: 'Thanks for delivering it back.'\n      else\n        redirect_to books_url, alert:  book_action.errors.full_messages\n      end\n    end\n  end\nend\n</code></pre> <p>And add routes for <code>rent</code> and <code>return_book</code> in <code>config/routes.rb</code>:</p> <pre><code>  resources :books do\n    post :rent\n    post :return_book\n  end\n</code></pre> <p>Now, it's time to change the current view to add such actions:</p> <pre><code>  &lt;tbody&gt;\n    &lt;% @books.each do |book| %&gt;\n      &lt;tr&gt;\n        &lt;td&gt;&lt;%= book.title %&gt;&lt;/td&gt;\n        &lt;% if book.available? %&gt;\n          &lt;td&gt;&lt;%= link_to 'Rent', rent_book_path(book), method: :post %&gt;&lt;/td&gt;\n        &lt;% else %&gt;\n          &lt;td&gt;(Rented)&lt;/td&gt;\n        &lt;% end %&gt;\n        &lt;% if current_user &amp;&amp; current_user.renting?(book) %&gt;\n           &lt;td&gt;&lt;%= link_to 'Return', return_book_path(book), method: :post %&gt;&lt;/td&gt;\n        &lt;% end %&gt;\n        &lt;td&gt;&lt;%= link_to 'Show', book %&gt;&lt;/td&gt;\n        &lt;td&gt;&lt;%= link_to 'Edit', edit_book_path(book) %&gt;&lt;/td&gt;\n        &lt;td&gt;&lt;%= link_to 'Destroy', book, method: :delete, data: { confirm: 'Do you really want to destroy this book?' } %&gt;&lt;/td&gt;\n      &lt;/tr&gt;\n    &lt;% end %&gt;\n  &lt;/tbody&gt;\n</code></pre> <p>Now is a good opportunity to introduce projectors.</p> <p>The actual implementation contains a few boilerplate code in the controller that make us repeat a few different logics that are already in the business action.</p> <p>Projectors can help with that. Avoiding the need for creating repetitive controller methods and re-verify preconditions and policies to decide what actions can be executed.</p>"},{"location":"tutorial/#setup-view-context-for-granite-projector","title":"Setup view context for Granite projector","text":"<p>You'll need to set up the master controller class. Let's create a file to configure what will be the base controller for Granite:</p> <p>File: <code>config/initializers/granite.rb</code> <pre><code>Granite.tap do |m|\n  m.base_controller = 'ApplicationController'\nend\n</code></pre></p> <p>The next step is to change <code>ApplicationController</code> to setup context view and allow Granite to inherit behavior from it.</p> <p><code>app/controllers/application_controller</code> <pre><code>class ApplicationController &lt; ActionController::Base\n  protect_from_forgery with: :exception\n\n  around_action :setup_granite_view_context\n  before_action { view_context }\n\n  protected\n\n  def setup_granite_view_context(&amp;block)\n    Granite.with_view_context(view_context, &amp;block)\n  end\nend\n</code></pre></p>"},{"location":"tutorial/#inline-projector","title":"Inline projector","text":"<p>The current <code>rent</code> and <code>returned_at</code> methods have a very similar structure.</p> <p>And the projectors allows to declare the HTTP method like <code>get</code> or <code>post</code> and mount it in a route as an anonymous controller.</p> <p>Inside the block, the action is already set with all parameters from the web request and ready to be executed.</p> <p>As the current controller actions are executed with <code>POST</code>, let's follow the same line and create a simple projector that allows to receive some post data and redirect to the resources list back.</p> <p>The projector will have a default <code>success_redirect</code> and <code>failure_redirect</code> after the action execution. By default, let's assume that we'll redirect it to the collection and render a positive notice or a negative alert to the previous action.</p> <pre><code>class InlineProjector &lt; Granite::Projector\n\n  post :perform, as: '' do\n    if action.perform!\n      redirect_to projector.success_redirect, notice: t('.notice')\n    else\n      messages = projector.action.errors.full_messages.to_sentence\n      redirect_to projector.failure_redirect, alert: t('.error', messages)\n    end\n  end\n\n  def collection_subject\n    action.subject.class.name.downcase.pluralize\n  end\n\n  def success_redirect\n    h.public_send(\"#{collection_subject}_path\")\n  end\n\n  def build_action(*args)\n    action_class.with(self.class.proxy_context || {performer: h.current_user}).new(*args)\n  end\nend\n</code></pre> <p>We also need to say who is the performer of the action. The <code>build_action</code> method in the projector is implemented to override the current performer in action with the <code>current_user</code>.</p> <p>Info</p> <p>Note that <code>h</code> is an alias for <code>view_context</code> and you can access anything from the controller through it.</p> <p>Now, it's time to say that we're going to use the projector inside the <code>Rent</code> action:</p> <p>File: <code>apq/actions/ba/book/rent.rb</code> <pre><code>class BA::Book::Rent &lt; BaseAction\n  subject :book\n\n+  projector :inline\n\n  allow_if { performer.is_a?(User) }\n\n  precondition do\n    decline_with(:unavailable) unless book.available?\n  end\n\n  private\n\n  def execute_perform!(*)\n    subject.available = false\n    subject.save!\n    Rental.create!(book: subject, user: performer)\n  end\nend\n</code></pre></p> <p>And also drop the method from the <code>BooksController</code>:</p> <p>File: <code>app/controllers/books_controller.rb</code> <pre><code>@@ -25,28 +25,6 @@ class BooksController &lt; ApplicationController\n     @book = Book.find(params[:id])\n   end\n\n-  # POST /books/1/rent\n-  def rent\n-    @book = Book.find(params[:book_id])\n-    book_action = BA::Book::Rent.as(current_user).new(@book)\n-    if book_action.perform\n-      redirect_to books_url, notice: 'Book was successfully rented.'\n-    else\n-      redirect_to books_url, alert:  book_action.errors.full_messages.to_sentence\n-    end\n-  end\n</code></pre></p> <p>As the last step, we need to change the <code>config/routes.rb</code> to use the <code>granite</code> to mount the <code>action#projector</code> into the defined routes.</p> <p>File: <code>config/routes.rb</code> <pre><code>Rails.application.routes.draw do\n  root 'books#index'\n\n  devise_for :users\n\n  resources :books do\n-   post :rent\n+   granite 'BA/book/rent#inline'\n    post 'return', to: 'books#return_book', as 'return'\n  end\nend\n</code></pre></p> <p>Warning</p> <p>As it's a tutorial, your next task is to do the same for <code>return_book</code>.</p> <ol> <li>Add <code>projector :inline</code> to <code>BA::Book::Return</code> class.</li> <li>Remove the controller method</li> <li>Refactor the <code>config/routes.rb</code> declaring the <code>granite 'action#projector'</code></li> </ol>"},{"location":"tutorial/#projector-helpers","title":"Projector Helpers","text":"<p>You can define useful methods for helping you rendering your view and improving the experience with your actions. Now, let's create a <code>button</code> function, to replace the action links in the current list.</p> <p>First, we need to have a method in our projector that can render the button if the action is performable.</p> <p>It will render nothing if the current user does not have access or it's an anonymous session.</p> <p>We'll render the action name stricken if the action is not performable with the error messages in the title, because if people mouse over, they can see the \"tooltip\" with why it's not possible to execute the action.</p> <pre><code>class InlineProjector &lt; Granite::Projector\n\n  # ...\n  # The previous methods remain here\n  # ...\n\n  def button(link_options = {})\n    return unless action.allowed?\n    if action.performable?\n      h.link_to action_label, perform_path, method: :post\n    end\n  end\n\n  def action_label\n    action.class.name.demodulize.underscore.humanize\n  end\nend\n</code></pre> <p>And now, we can replace the links with the new <code>button</code> function:</p> <pre><code>  &lt;tbody&gt;\n    &lt;% @books.each do |book| %&gt;\n      &lt;tr&gt;\n        &lt;td&gt;&lt;%= book.title %&gt;&lt;/td&gt;\n        &lt;td&gt;&lt;%= Ba::Book::Rent.as(current_user).new(book).inline.button%&gt;&lt;/td&gt;\n        &lt;td&gt;&lt;%= Ba::Book::Return.as(current_user).new(book).inline.button%&gt;&lt;/td&gt;\n        &lt;td&gt;... more links here ...&lt;/td&gt;\n      &lt;/tr&gt;\n    &lt;% end %&gt;\n  &lt;/tbody&gt;\n</code></pre> <p>Now it's clear, and the \"Return\" link will appear only for the user that rented the book.</p>"},{"location":"tutorial/#wishlist-domain","title":"Wishlist domain","text":"<p>As we are still working on the description of the wishlist domain, we encourage you to take the initiative and implement it yourself. We believe this will be a great opportunity for you to apply your own creativity and problem-solving skills, and we are always here to support you along the way.</p>"},{"location":"tutorial/#wishlistadd-action","title":"Wishlist::Add action","text":"<p>To be done.</p>"},{"location":"tutorial/#wishlistremove-action","title":"Wishlist::Remove action","text":"<p>To be done.</p>"},{"location":"tutorial/#wishlistnotifyavailability-action","title":"Wishlist::NotifyAvailability action","text":"<p>To be done.</p>"},{"location":"tutorial/#conclusion","title":"Conclusion","text":"<p>To conclude, you have learned how to work with Granite, and we are excited to see you apply this knowledge to your upcoming project. We are confident that Granite will simplify your development process and allow you to focus on the more important aspects of your application. As always, please do not hesitate to reach out to us if you have any questions or need further assistance.</p>"}]}